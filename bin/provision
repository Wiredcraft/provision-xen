#!/usr/bin/env python
"""
Usage: 
    provision (--version|--help)
    provision --config=<config>
    provision [--cpu=<cpu>] [--ram=<ram>] [--disk=<disk>] [--swap=<swap>]
                [--interface=<interface>...] [--bridge=<bridge>...]
                [--hostname=<hostname>] --image=<image> <name>

Options:
    --config=<config>                   Path to a config file that specify the details of a server
    --cpu=<cpu>                         Number of CPU cores to allocate to the server [default: 4]
    --ram=<ram>                         Amount of RAM to allocate to the server (in MB) [default: 512]
    --disk=<disk>                       Disk size to allocate to the server (in GB) [default: 4]
    --swap=<swap>                       SWAP size to allocate to the server (in GB) [default: 0.5]
    --interface=<interface>...          List of network interfaces (details below) [default: eth0:dhcp]
    --bridge=<bridge>...                List of network bridges (details below) [default: xenbr0:eth0]
    --hostname=<hostname>               A hostname to apply to the server
    --image=<image>                     A template image to use and base the server on
    <name>                              A unique name for the server


A typical configuration for a host looks like this:

{
    "name": "unique_name",
    "hostname": "some_hostname",
    "image": "debian8/base",
    "cpu": 4,
    "ram": 512,
    "disk": 20,
    "swap": 2,
    "interfaces": [
        {
            "name": "eth0",
            "type": "static",
            "address": "1.1.1.2",
            "netmask": "255.255.255.0",
            "gateway": "1.1.1.1"
        },
        {
            "name": "eth1",
            "type": "dhcp"
        }
    ],
    "bridges": {
        "xenbr0": ["eth0"],
        "xenbr1": ["eth1"]
    }
}

When using the CLI parameters, the interfaces and bridges definitions need to follow a specific format.

Interfaces: 
  - format: "if_name:type:address:mask:gateway"
  - details:
    - if_name: a valid interface name; e.g. eth0 / eth1
    - type: either dhcp or static, it dhcp other parameters are ignored - default dhcp
    - address: only if static, a valid IP address
    - mask (optional): only if static, a valid netmask - default to 255.255.255.0
    - gateway (optional): only if static, the gateway IP address
  - e.g:
    - 'eth0' --> eth0 is dhcp based
    - 'eth1:dhcp' --> eth1 is dhcp based
    - 'eth1:static:192.168.1.100::192.168.1.1' --> eth1 is static IP .100/24 with gateway to .1

Bridges:
  - format: "br_name:if_name1:if_name2:..."
  - details:
    - br_name: an existing bridge name; e.g. xenbr0
    - if_names: a list of interfaces to allocate to the bridge
  - e.g:
    - 'xenbr0:eth0' --> eth0 bind to xenbr0
    - 'xenbr1:eth0:eth1' --> eth0 and eth1 bind to xenbr1

"""

import docopt
import os
import sys
from provision import __version__


def _parse_interface(interface):
    '''
    Parse the interface string and return a proper dict
    '''
    iface = {
        'type': 'dhcp'
    }

    params = interface.split(':')
    if len(params) == 1:
        iface.update({'name': params[0]})
    elif len(params) == 2:
        iface.update({'name': params[0], 'type': params[1]})
    elif len(params) == 3:
        iface.update({'name': params[0], 'type': params[1], 'address': params[2], 'netmask': '255.255.255.0'})
    elif len(params) >= 4:
        # Handle netmask
        if params[3]:
            netmask = params[3]
        else:
            netmask = '255.255.255.0'
        iface.update({'name': params[0], 'type': params[1], 'address': params[2], 'netmask': netmask})
        # Handle gateway if defined
        if len(params) == 5:
            iface.update({'gateway': params[4]})
    else:
        # Invalid number of args
        raise RuntimeError('Too many parameters for interface')
    return iface

def _parse_bridge(bridge):
    '''
    Parse the bridges
    '''
    br = {}

    params = bridge.split(':')
    if len(params) >= 1:
        br.update({params[0]: params[1:]})
    else:
        # Invalid number of args
        raise RuntimeError('Invalid parameters for bridge')
    return br


def handle_provision(args):
    '''
    Provision the server
    '''
    print "do provision"
    print args

    interfaces = [ _parse_interface(interface) for interface in args.get('--interface') ]
    bridges = {}
    for bridge in args.get('--bridge'):
        bridges.update(_parse_bridge(bridge))

    server = {
        'name': args.get('<name>'),
        'hostname': args.get('--hostname'),
        'image': args.get('--image'),
        'cpu': int(args.get('--cpu')),
        'ram': int(args.get('--ram')),
        'disk': float(args.get('--disk')),
        'swap': float(args.get('--swap')),
        'interfaces': interfaces,
        'bridges': bridges
    }
    print server

if __name__ == '__main__':
    args = docopt.docopt(
        __doc__,
        version="version "+ __version__,
        help=True
    )

    if args.get('--config'):
        print "Does not support yet the config file - use the CLI arguments."
        sys.exit(1)
    else:
        handle_provision(args)